#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const int NUM_LIGHTS = 100;

#define LIGHT_INTENSITY 6000


struct Light
{
	int Type;
	vec4 LightPosition;
	vec4 LightColour;
	mat4 LightSpaceMatrix;
};

layout(set = 0, binding = 0) uniform CandidatesPassUniforms
{
    int frameIndex;
    vec2 viewportSize;
    int M;
} cand_ubo;

#define CANDIDATE_MAX cand_ubo.M
const float PI = 3.14159265359;

layout(set = 0, binding = 1) uniform LightBuffer {
	Light lights[NUM_LIGHTS];
} lightData;

layout(set = 0, binding = 2) uniform sampler2D g_world_positions;
layout(set = 0, binding = 3) uniform sampler2D g_world_normals;
layout(set = 0, binding = 4) uniform sampler2D g_albedo;
layout(set = 0, binding = 5, rgba16f) uniform image2D reservoir_output_image;
layout(set = 0, binding = 6) uniform accelerationStructureEXT topLevelAS;

layout(set = 0, binding = 7) uniform SceneUniform
{
	mat4 model;
	mat4 view;
	mat4 projection;
    vec4 cameraPosition;
    vec2 viewportSize;
	float fov;
	float nearPlane;
	float farPlane;
} ubo;

layout(set = 0, binding = 8) uniform sampler2D g_metallic_roughness;

// Reference: https://github.com/NVIDIAGameWorks/RTXGI-DDGI/blob/main/samples/test-harness/shaders/include/Random.hlsl#L42
uint WangHash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

uint Xorshift(uint seed)
{
    // Xorshift algorithm from George Marsaglia's paper
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

float GetRandomNumber(inout uint seed)
{
    seed = WangHash(seed);
    return float(Xorshift(seed)) * (1.f / 4294967296.f);
}

vec2 GetRandomHashValue01(inout uint seed)
{
    float u = GetRandomNumber(seed);
    float v = GetRandomNumber(seed);
    return vec2(u, v);
}


vec2 GetRandomHashValue(inout uint seed)
{
    float u = GetRandomNumber(seed) * 2.0 - 1.0;
    float v = GetRandomNumber(seed) * 2.0 - 1.0; // Seed is modified in-place
    return vec2(u, v);
}

float inShadow(vec3 position, vec3 normal, float distToLight, vec3 lightDir)
{
    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, topLevelAS,
                          gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
                          0xFF,
                          position + normal * 0.001, // offset to avoid self-intersection
                          0.0,
                          lightDir,
                          distToLight - 0.001);

    bool occluded = rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT;

    return occluded ? 0.0 : 1.0;
}

// PBR Rendering based on learnings from:
// Joey De Vries (2020). Learn OpenGL: Learn modern OpenGL graphics programming in a step-by-step fashion. Kendall & Welling.
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return num / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

vec3 GetLightRadiance(int light_index, vec3 normal,vec3 world_pos, vec3 albedo, float metallic, float roughness)
{
    vec3 N = normalize(normal);
    vec3 V = normalize(ubo.cameraPosition.xyz - world_pos);

    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    Light light = lightData.lights[light_index];
    vec3 L = normalize(light.LightPosition.xyz - world_pos);
    vec3 H = normalize(V + L);
    float dist = length(light.LightPosition.xyz - world_pos);
    float attenuation = 1.0 / (dist * dist);
    vec3 radiance = light.LightColour.rgb * attenuation * LIGHT_INTENSITY;

    // Cook-Torrance BRDF
    float NDF = DistributionGGX(N, H, roughness);
    float G   = GeometrySmith(N, V, L, roughness);
    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);

    vec3 numerator    = NDF * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; // prevent divide by zero
    vec3 specular     = numerator / denominator;
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}


// @NOTE: Reservoir can also store the PDF. This is useful if we have multiple PDF which you draw samples from.
// This is needed for MIS which will need to be computed if using multiple PDF in both spatial and temporal
struct Reservoir
{
    int index;
    float W_y;
    float W_sum;
    int M;
};

// This is Weighted Reservoir Sampling with RIS
void update(inout uint seed, inout Reservoir reservoir, in float xi_weight, int index)
{
    reservoir.W_sum = reservoir.W_sum + xi_weight;
    float r = GetRandomNumber(seed);
    reservoir.M = reservoir.M + 1;
    if(r < (xi_weight / reservoir.W_sum))
    {
        reservoir.index = index;
    }
}

void RISReservoir(inout Reservoir reservoir, inout uint seed, vec3 pos, vec3 n, vec3 albedo, float metallic, float roughness)
{
    const float rcpUniformDistributionWeight = float(NUM_LIGHTS); // PDF of uniform distribution = 1 / total number of lights. Reciporal of that PDF is the light count e.g. 1 / 10 = 0.1 -> rcp = 1 / (1 / 10) = 10.0
    const float rcpM = 1.0 / float(CANDIDATE_MAX);

    // Picking any light direction has a uniform distribution
    for (int i = 0; i < CANDIDATE_MAX; i++) {

        // Pick a random light from all lights
        int randomLightIndex = int(GetRandomNumber(seed) * float(NUM_LIGHTS));
        Light light = lightData.lights[randomLightIndex];

        // Compute RIS weight for this candidate light
        float F_x = length(GetLightRadiance(randomLightIndex, n, pos, albedo, metallic, roughness)); // Use full PBR eval to get F_x

        // This is p^q(x_i) / p(x_i) where p^q(x_i) is the target function F_x and p(x_i) is the PDF of the uniform distribution which is 1 / NUM_LIGHTS. So we can compute the weight as F_x * rcpUniformDistributionWeight = F_x * (1 / NUM_LIGHTS) = F_x / NUM_LIGHTS
        float xi_weight = F_x > 0.0 ? rcpM * F_x * rcpUniformDistributionWeight : 0.0; // Move 1.0 / M to here when computing weight as suggested
        update(seed, reservoir, xi_weight, randomLightIndex);
    }
}


/*

Weighting in RIS works slightly differently to tranditional. While weighting is used, its not a PDF.
Instead we have an unbiased contribution weight called W_x which replaces 1/P(X).
A single sample X can have many valid W_x depending on the initial candidates samples.
This is because the initial candidates are chosen at random and for each set of them, any sample will
have a different weighing relative to them.
This means W_x is not a determiistic function of X, its a random variable. Since they're unbiased,
1/P(X) can be replaced by W_x.

*/

void RISReservoirSampling(vec3 pos, vec3 n, vec3 albedo, float metallic, float roughness)
{
    uvec2 dispatchSize = uvec2(cand_ubo.viewportSize / 8);
    uint launchWidth = dispatchSize.x * gl_WorkGroupSize.x;
    uint seed = uint(gl_GlobalInvocationID.y * launchWidth) + gl_GlobalInvocationID.x;
    seed *= cand_ubo.frameIndex;

    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);

    Reservoir reservoir;
    reservoir.index = -1;
    reservoir.W_y = 0.0;
    reservoir.W_sum = 0.0;
    reservoir.M = 0;

    // Compute the weights of the candidates from the original distribution
    RISReservoir(reservoir, seed, pos, n, albedo, metallic, roughness);

    bool isValidIndex = reservoir.index >= 0;

    if(!isValidIndex)
    {
        imageStore(reservoir_output_image, ivec2(gl_GlobalInvocationID.xy), vec4(-1, 0.0, 0.0, 0.0));
        return;
    }

    // The selected light
    int light_index = reservoir.index;
    Light LightSource = lightData.lights[light_index];
    float dist = length(LightSource.LightPosition.xyz - pos);
    vec3 light_dir = normalize(LightSource.LightPosition.xyz - pos);

    // Compute the light weight to prevent bias
    // W_x = (sum(w_i) / M) / pdf(x)
    // Written as: 1 / pdf(x) * (1 / m * sum(w_i)), but remember 1 / pdf(x) and 1 / m is the same as dividing by them since 1 / x is rcp
    float F_x = length(GetLightRadiance(light_index, n, pos, albedo, metallic, roughness)); // Use full PBR eval to get F_x

    // Evaluate the unbiased constribuion weight W_x
    // We moved rcpM = 1 / float(CANDIDATE_MAX) to func RISReservoir which is computing weight for each candidate as suggested by paper
    reservoir.W_y = F_x > 0.0 ? (1.0 / F_x) * (reservoir.W_sum) : 0.0;

    // Perform visibility testing. Set reservoir weight to 0 if in shadow
    float Visibility = inShadow(pos, n, dist, light_dir);
    reservoir.W_y *= Visibility;

    // Set to 1
    // reservoir.M = 1;
    // Store the current select sample Y, probabilistic weight W_y, and number of candidates M
    imageStore(reservoir_output_image, ivec2(gl_GlobalInvocationID.xy), vec4(reservoir.index, reservoir.W_y, reservoir.M, 0.0));
}

void main() {

    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    // Get world and normal data
    vec4 world_position = texelFetch(g_world_positions, coords, 0);
    vec3 world_normal   = normalize(texelFetch(g_world_normals, coords, 0).xyz * 2.0 - 1.0);
    vec4 albedo = texelFetch(g_albedo, coords, 0);
    float metallic = texelFetch(g_metallic_roughness, coords, 0).r;
    float roughness = texelFetch(g_metallic_roughness, coords, 0).g;

    RISReservoirSampling(world_position.xyz, world_normal.xyz, albedo.rgb, metallic, roughness);
}