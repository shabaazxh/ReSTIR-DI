#version 460

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const int NUM_LIGHTS = 100;
#define LIGHT_INTENSITY 6000
#define PI 3.14159265359

struct Light
{
	int Type;
	vec4 LightPosition;
	vec4 LightColour;
	mat4 LightSpaceMatrix;
};

layout(set = 0, binding = 0) uniform ShadingPassUniforms
{
    int reservoir_pass;
} shading_ubo;


layout(set = 0, binding = 1) uniform LightBuffer {
	Light lights[NUM_LIGHTS];
} lightData;

layout(set = 0, binding = 2) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 3) uniform sampler2D g_buffer_world_position;
layout(set = 0, binding = 4) uniform sampler2D g_buffer_normals;
layout(set = 0, binding = 5) uniform sampler2D g_albedo;
layout(set = 0, binding = 6) uniform sampler2D initial_candidates_texture;
layout(set = 0, binding = 7) uniform sampler2D temporal_pass_reservoirs;
layout(set = 0, binding = 8) uniform sampler2D spatial_pass_reservoirs;
layout(set = 0, binding = 9, rgba32f) uniform image2D shading_result_image;

layout(set = 0, binding = 10) uniform SceneUniform
{
	mat4 model;
	mat4 view;
	mat4 projection;
    vec4 cameraPosition;
    vec2 viewportSize;
	float fov;
	float nearPlane;
	float farPlane;
} ubo;

layout(set = 0, binding = 11) uniform sampler2D g_metallic_roughness;

// PBR Rendering based on learnings from:
// Joey De Vries (2020). Learn OpenGL: Learn modern OpenGL graphics programming in a step-by-step fashion. Kendall & Welling.
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return num / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

vec3 GetLightRadiance(int light_index, vec3 normal,vec3 world_pos, vec3 albedo, float metallic, float roughness)
{
    vec3 N = normalize(normal);
    vec3 V = normalize(ubo.cameraPosition.xyz - world_pos);

    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    Light light = lightData.lights[light_index];
    vec3 L = normalize(light.LightPosition.xyz - world_pos);
    vec3 H = normalize(V + L);
    float distance = length(light.LightPosition.xyz - world_pos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = light.LightColour.rgb * attenuation * LIGHT_INTENSITY;

    // Cook-Torrance BRDF
    float NDF = DistributionGGX(N, H, roughness);
    float G   = GeometrySmith(N, V, L, roughness);
    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);

    vec3 numerator    = NDF * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; // prevent divide by zero
    vec3 specular     = numerator / denominator;
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;
    float NdotL = max(dot(N, L), 0.0);
    return (kD * albedo / PI + specular) * radiance * NdotL;
}

struct Reservoir
{
    int index;
    float W_y;
    float W_sum;
    int M;
};

float inShadow(vec3 position, vec3 normal, float distToLight, vec3 lightDir)
{
    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, topLevelAS,
                          gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
                          0xFF,
                          position + normal * 0.001, // offset to avoid self-intersection
                          0.0,
                          lightDir,
                          distToLight);

    while (rayQueryProceedEXT(rq)) {
        // Just keep iterating until first hit or end
    }
    bool occluded = rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT;

    return occluded ? 0.0 : 1.0;
}

Reservoir SelectReservoirPass()
{
    Reservoir reservoir;

    vec4 reservoir_data;
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    switch (shading_ubo.reservoir_pass)
    {
        case 0:
            reservoir_data = texelFetch(initial_candidates_texture, coord, 0);
            break;
        case 1:
            reservoir_data = texelFetch(spatial_pass_reservoirs, coord, 0);
            // reservoir_data = texelFetch(temporal_pass_reservoirs, coord, 0); // doesn't make sense since temporal still takes data from spatial, its not literally only spatial because of the way its coded in the shader
            break;
        default:
            reservoir_data = vec4(0.0);
            break;
    }

    reservoir.index = int(reservoir_data.x);
    reservoir.W_y = reservoir_data.y;
    reservoir.M = int(reservoir_data.z);

    return reservoir;
}


void main() {

    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    vec3 throughput = vec3(1.0);

    // Get world and normal data
    vec4 world_position = texelFetch(g_buffer_world_position, coords, 0);
    vec3 world_normal   = normalize(texelFetch(g_buffer_normals, coords, 0).xyz * 2.0 - 1.0);
    vec3 albedo = texelFetch(g_albedo, coords, 0).rgb;
    float metallic = texelFetch(g_metallic_roughness, coords, 0).r;
    float roughness = texelFetch(g_metallic_roughness, coords, 0).g;

    Reservoir reservoir = SelectReservoirPass();

    bool isValidReservoir = reservoir.index >= 0;

    if(!isValidReservoir) {
        imageStore(shading_result_image, coords, vec4(0.0, 0.0, 0.0, 1.0)); // shade with red for invalid reservoirs
        return;
    }

    Light L = lightData.lights[reservoir.index];

    vec3 light_dir = normalize(L.LightPosition.xyz - world_position.xyz);
    float dist = length(L.LightPosition.xyz - world_position.xyz);

    vec3 F_x = GetLightRadiance(reservoir.index, world_normal.xyz, world_position.xyz, albedo, metallic, roughness);

    float Visibility = inShadow(world_position.xyz, world_normal.xyz, dist, light_dir);

    vec3 directlighting = F_x;
    vec3 radiance = throughput * directlighting * reservoir.W_y * Visibility;

    imageStore(shading_result_image, coords, vec4(radiance.rgb, 0.0));
}